# 高速入出力

このページでは、`wkit.h` の高速入出力関数について説明します。

---

## 目次

- [概要](#概要)
- [初期化](#初期化)
- [入力関数](#入力関数)
- [出力関数](#出力関数)
- [バッファ管理](#バッファ管理)

---

## 概要

標準の `scanf` / `printf` は遅いため、競技プログラミングでは `getchar_unlocked` / バッファリングを使った高速I/Oが必要になることがあります。

このライブラリでは以下の2つの方式を提供しています：

1. **高速入力**: `getchar_unlocked` を使用
2. **高速出力**: バッファに書き込み、最後にまとめて `fwrite`

---

## 初期化

### cp_init_fastio

**概要**: 高速出力バッファを有効化する（`atexit` で自動フラッシュを登録）

**シグネチャ**:
```c
void cp_init_fastio(void);
```

**使用例**:
```c
int main(void) {
    cp_init_fastio();  // プログラム開始時に呼ぶ
    // ... 処理 ...
    return 0;
}
```

**注意点**:
- これを呼ばないと、`write_*` 系関数の出力がフラッシュされない場合がある
- `atexit` で `flush_out` を登録するので、明示的にフラッシュしなくてもプログラム終了時に出力される

---

## 入力関数

### fast_read_int

**概要**: 整数（int）を1つ読み込む

**シグネチャ**:
```c
int fast_read_int(void);
```

**戻り値**: 読み込んだ整数値

**計算量**: O(桁数)

**使用例**:
```c
int n = fast_read_int();
int a = fast_read_int();
```

**注意点**:
- 空白・改行は自動でスキップされる
- 負の数にも対応

---

### fast_read_long

**概要**: 整数（long long）を1つ読み込む

**シグネチャ**:
```c
ll fast_read_long(void);
```

**戻り値**: 読み込んだ整数値（ll型）

**計算量**: O(桁数)

**使用例**:
```c
ll x = fast_read_long();
```

---

### fast_read_ull

**概要**: 符号なし整数（unsigned long long）を1つ読み込む

**シグネチャ**:
```c
ull fast_read_ull(void);
```

**戻り値**: 読み込んだ整数値（ull型）

**計算量**: O(桁数)

---

### fast_read_int2

**概要**: 整数を読み込み、成功したかどうかを返す

**シグネチャ**:
```c
bool fast_read_int2(int* out);
```

**引数**:
| 名前 | 型 | 説明 |
|------|-----|------|
| out | int* | 読み込んだ値を格納するポインタ |

**戻り値**: 読み込みに成功したら `true`、EOF なら `false`

**使用例**:
```c
int x;
while (fast_read_int2(&x)) {
    // x を処理
}
```

---

### fast_read_ll2

**概要**: long long を読み込み、成功したかどうかを返す

**シグネチャ**:
```c
bool fast_read_ll2(ll* out);
```

**引数**:
| 名前 | 型 | 説明 |
|------|-----|------|
| out | ll* | 読み込んだ値を格納するポインタ |

**戻り値**: 読み込みに成功したら `true`、EOF なら `false`

---

### fast_read_ull2

**概要**: unsigned long long を読み込み、成功したかどうかを返す

**シグネチャ**:
```c
bool fast_read_ull2(ull* out);
```

---

### fast_read_char

**概要**: 空白以外の1文字を読み込む

**シグネチャ**:
```c
int fast_read_char(void);
```

**戻り値**: 読み込んだ文字（int型）、EOFの場合は `EOF`

**計算量**: O(1)

**使用例**:
```c
int c = fast_read_char();  // 'A' や '#' など
if (c == '.') {
    // ...
}
```

**注意点**:
- 空白・改行・タブはスキップされる

---

### fast_read_token

**概要**: 空白区切りのトークン（文字列）を読み込む

**シグネチャ**:
```c
int fast_read_token(char* buf, int maxlen);
```

**引数**:
| 名前 | 型 | 説明 |
|------|-----|------|
| buf | char* | 読み込んだ文字列を格納するバッファ |
| maxlen | int | バッファの最大サイズ |

**戻り値**: 読み込んだ文字数

**計算量**: O(文字列長)

**使用例**:
```c
char s[100];
int len = fast_read_token(s, 100);
printf("読み込んだ文字列: %s (長さ: %d)\n", s, len);
```

**注意点**:
- バッファは自動でNULL終端される
- `maxlen` を超える部分は切り捨てられる

---

### fast_read_line

**概要**: 1行を読み込む（改行は含まない）

**シグネチャ**:
```c
int fast_read_line(char* buf, int maxlen);
```

**引数**:
| 名前 | 型 | 説明 |
|------|-----|------|
| buf | char* | 読み込んだ文字列を格納するバッファ |
| maxlen | int | バッファの最大サイズ |

**戻り値**: 読み込んだ文字数

**計算量**: O(文字列長)

**使用例**:
```c
char line[1000];
fast_read_line(line, 1000);
```

**注意点**:
- 先頭の空白はスキップ**されない**
- 末尾の改行は含まれない

---

## 出力関数

### write_char

**概要**: 1文字を出力バッファに書き込む

**シグネチャ**:
```c
void write_char(char c);
```

**計算量**: O(1)（バッファフルの場合は flush が走る）

**使用例**:
```c
write_char('A');
write_char('\n');
```

---

### write_str

**概要**: 文字列を出力バッファに書き込む

**シグネチャ**:
```c
void write_str(const char* s);
```

**計算量**: O(文字列長)

**使用例**:
```c
write_str("Hello, World!");
write_ln();
```

---

### write_ll

**概要**: long long 型の整数を出力

**シグネチャ**:
```c
void write_ll(ll x);
```

**計算量**: O(桁数)

**使用例**:
```c
write_ll(123456789012345LL);
write_ln();
```

**注意点**:
- 負の数にも対応

---

### write_ull

**概要**: unsigned long long 型の整数を出力

**シグネチャ**:
```c
void write_ull(ull x);
```

**計算量**: O(桁数)

---

### write_ln

**概要**: 改行を出力

**シグネチャ**:
```c
void write_ln(void);
```

**使用例**:
```c
write_ll(ans);
write_ln();
```

---

### write_double

**概要**: 浮動小数点数を指定した精度で出力

**シグネチャ**:
```c
void write_double(double x, int prec);
```

**引数**:
| 名前 | 型 | 説明 |
|------|-----|------|
| x | double | 出力する値 |
| prec | int | 小数点以下の桁数 |

**計算量**: O(prec)

**使用例**:
```c
write_double(3.14159265, 6);  // "3.141593"
write_ln();
```

---

## バッファ管理

### flush_out

**概要**: 出力バッファの内容を標準出力に書き出す

**シグネチャ**:
```c
void flush_out(void);
```

**使用例**:
```c
write_ll(ans);
write_ln();
flush_out();  // 即座に出力
```

**注意点**:
- `cp_init_fastio()` を呼んでいれば、プログラム終了時に自動で呼ばれる
- インタラクティブ問題では手動でフラッシュが必要な場合がある

---

## 配列出力ヘルパー

### print_arr_int

**概要**: int配列を区切り文字付きで出力

**シグネチャ**:
```c
void print_arr_int(const int* a, int n, char sep);
```

**引数**:
| 名前 | 型 | 説明 |
|------|-----|------|
| a | const int* | 出力する配列 |
| n | int | 配列の要素数 |
| sep | char | 区切り文字（通常は ' '） |

**使用例**:
```c
int arr[] = {1, 2, 3, 4, 5};
print_arr_int(arr, 5, ' ');  // "1 2 3 4 5\n"
```

---

### print_arr_ll

**概要**: ll配列を区切り文字付きで出力

**シグネチャ**:
```c
void print_arr_ll(const ll* a, int n, char sep);
```

**使用例**:
```c
ll arr[] = {100, 200, 300};
print_arr_ll(arr, 3, ' ');  // "100 200 300\n"
```

---

## 使用パターン

### 基本的な使い方

```c
#include "wkit.h"

int main(void) {
    cp_init_fastio();
    
    int n = fast_read_int();
    ll sum = 0;
    rep(i, n) {
        ll a = fast_read_long();
        sum += a;
    }
    
    write_ll(sum);
    write_ln();
    
    return 0;
}
```

### 複数の値を1行で出力

```c
int a = 10, b = 20, c = 30;
write_ll(a);
write_char(' ');
write_ll(b);
write_char(' ');
write_ll(c);
write_ln();
// 出力: "10 20 30\n"
```

### グリッドの読み込み

```c
int H = fast_read_int();
int W = fast_read_int();
char grid[1000][1000];
rep(i, H) {
    fast_read_token(grid[i], W + 1);
}
```
